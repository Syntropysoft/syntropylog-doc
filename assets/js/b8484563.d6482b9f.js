"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[41],{8397:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"examples/testing-transports-concepts","title":"Testing Transport Concepts","description":"Understanding transports as spies and testing patterns","source":"@site/docs/examples/32-testing-transports-concepts.md","sourceDirName":"examples","slug":"/examples/testing-transports-concepts","permalink":"/syntropylog-doc/docs/examples/testing-transports-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/Syntropysoft/SyntropyLog/tree/main/docs-docusaurus/docs/examples/32-testing-transports-concepts.md","tags":[],"version":"current","sidebarPosition":32,"frontMatter":{"id":"testing-transports-concepts","title":"Testing Transport Concepts","sidebar_label":"Testing Transport Concepts","description":"Understanding transports as spies and testing patterns"},"sidebar":"tutorialSidebar","previous":{"title":"Testing Serializers","permalink":"/syntropylog-doc/docs/examples/testing-serializers"},"next":{"title":"Testing Overview","permalink":"/syntropylog-doc/docs/examples/testing-overview"}}');var r=t(4848),i=t(8453);const o={id:"testing-transports-concepts",title:"Testing Transport Concepts",sidebar_label:"Testing Transport Concepts",description:"Understanding transports as spies and testing patterns"},a="Testing Transport Concepts",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"<strong>Transports as Spies</strong>",id:"transports-as-spies",level:3},{value:"<strong>Framework Agnostic Testing</strong>",id:"framework-agnostic-testing",level:3},{value:"<strong>Declarative Patterns</strong>",id:"declarative-patterns",level:3},{value:"Example Code",id:"example-code",level:2},{value:"<strong>Notification Service</strong>",id:"notification-service",level:3},{value:"<strong>Testing Transport Concepts</strong>",id:"testing-transport-concepts-1",level:3},{value:"Test Coverage",id:"test-coverage",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"<strong>1. Transports are Spies</strong>",id:"1-transports-are-spies",level:3},{value:"<strong>2. Framework Agnostic Testing</strong>",id:"2-framework-agnostic-testing",level:3},{value:"<strong>3. Declarative Patterns</strong>",id:"3-declarative-patterns",level:3},{value:"<strong>4. Comprehensive Coverage</strong>",id:"4-comprehensive-coverage",level:3},{value:"<strong>5. Zero External Dependencies</strong>",id:"5-zero-external-dependencies",level:3},{value:"<strong>6. Silent Observer Philosophy</strong>",id:"6-silent-observer-philosophy",level:3},{value:"Related Examples",id:"related-examples",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"testing-transport-concepts",children:"Testing Transport Concepts"})}),"\n",(0,r.jsx)(n.p,{children:"This example demonstrates the conceptual understanding of transports and how to test them using framework-agnostic patterns."}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\ud83d\udce6 Version"}),": This example corresponds to ",(0,r.jsx)(n.strong,{children:"SyntropyLog v0.7.0"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(n.p,{children:["Transports are essentially ",(0,r.jsx)(n.strong,{children:"spies"})," - they capture and store log entries for inspection. This example shows how to:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Understand transports as testing utilities"}),"\n",(0,r.jsx)(n.li,{children:"Use framework-agnostic testing patterns"}),"\n",(0,r.jsx)(n.li,{children:"Combine all testing concepts learned"}),"\n",(0,r.jsx)(n.li,{children:"Test framework boilerplate functions"}),"\n",(0,r.jsx)(n.li,{children:"Achieve high test coverage"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"transports-as-spies",children:(0,r.jsx)(n.strong,{children:"Transports as Spies"})}),"\n",(0,r.jsx)(n.p,{children:"Transports are designed to capture log entries in memory for testing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { SpyTransport } from 'syntropylog/testing';\n\n// Create a transport that captures logs\nconst spyTransport = new SpyTransport();\n\n// Log entries are stored in memory\nlogger.info('User created', { userId: 123 });\n\n// Inspect captured logs\nconst entries = spyTransport.getEntries();\nexpect(entries).toHaveLength(1);\nexpect(entries[0].message).toBe('User created');\n"})}),"\n",(0,r.jsx)(n.h3,{id:"framework-agnostic-testing",children:(0,r.jsx)(n.strong,{children:"Framework Agnostic Testing"})}),"\n",(0,r.jsx)(n.p,{children:"All testing patterns work with any framework:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Vitest\nconst testHelper = createTestHelper(vi.fn);\n\n// Jest\nconst testHelper = createTestHelper(jest.fn);\n\n// Jasmine\nconst testHelper = createTestHelper(jasmine.createSpy);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"declarative-patterns",children:(0,r.jsx)(n.strong,{children:"Declarative Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"Tests focus on behavior and outcomes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"it('should send notification when user is created', async () => {\n  // Arrange\n  const user = { id: 1, name: 'John' };\n  \n  // Act\n  await notificationService.sendWelcomeNotification(user);\n  \n  // Assert\n  expect(mockTransport.getEntries()).toContainEqual(\n    expect.objectContaining({\n      level: 'info',\n      message: 'Welcome notification sent',\n      userId: 1\n    })\n  );\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"example-code",children:"Example Code"}),"\n",(0,r.jsx)(n.h3,{id:"notification-service",children:(0,r.jsx)(n.strong,{children:"Notification Service"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// src/index.ts\nimport { syntropyLog } from 'syntropylog';\n\nexport class NotificationService {\n  private logger = syntropyLog.getLogger();\n\n  async sendWelcomeNotification(user: any): Promise<void> {\n    this.logger.info('Sending welcome notification', { userId: user.id });\n    \n    // Simulate notification logic\n    await this.delay(100);\n    \n    this.logger.info('Welcome notification sent', { \n      userId: user.id, \n      email: user.email \n    });\n  }\n\n  async sendPasswordReset(user: any): Promise<void> {\n    this.logger.warn('Password reset requested', { userId: user.id });\n    \n    // Simulate password reset logic\n    await this.delay(200);\n    \n    this.logger.info('Password reset email sent', { \n      userId: user.id, \n      email: user.email \n    });\n  }\n\n  private delay(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Framework boilerplate functions for testing\nexport async function initializeSyntropyLog() {\n  await syntropyLog.init({\n    logger: {\n      serviceName: 'notification-service',\n      level: 'info',\n    },\n  });\n  return syntropyLog;\n}\n\nexport async function shutdownSyntropyLog() {\n  await syntropyLog.shutdown();\n  return { success: true };\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"testing-transport-concepts-1",children:(0,r.jsx)(n.strong,{children:"Testing Transport Concepts"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// tests/transports-concepts.test.ts\nimport { describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { createTestHelper } from 'syntropylog/testing';\nimport { NotificationService, initializeSyntropyLog, shutdownSyntropyLog } from '../src/index';\n\ndescribe('Transport Concepts', () => {\n  const testHelper = createTestHelper(vi.fn);\n  let notificationService: NotificationService;\n\n  beforeEach(() => {\n    testHelper.beforeEach();\n    notificationService = new NotificationService();\n  });\n\n  afterEach(() => {\n    testHelper.afterEach();\n  });\n\n  describe('Transports as Spies', () => {\n    it('should capture log entries in memory', async () => {\n      const user = { id: 123, name: 'John', email: 'john@example.com' };\n      \n      await notificationService.sendWelcomeNotification(user);\n      \n      const entries = testHelper.mockSyntropyLog.logger.transports[0].getEntries();\n      expect(entries).toHaveLength(2);\n      expect(entries[0].message).toBe('Sending welcome notification');\n      expect(entries[1].message).toBe('Welcome notification sent');\n    });\n\n    it('should include metadata in log entries', async () => {\n      const user = { id: 456, name: 'Jane', email: 'jane@example.com' };\n      \n      await notificationService.sendPasswordReset(user);\n      \n      const entries = testHelper.mockSyntropyLog.logger.transports[0].getEntries();\n      expect(entries[0]).toMatchObject({\n        level: 'warn',\n        message: 'Password reset requested',\n        userId: 456\n      });\n      expect(entries[1]).toMatchObject({\n        level: 'info',\n        message: 'Password reset email sent',\n        userId: 456,\n        email: 'jane@example.com'\n      });\n    });\n  });\n\n  describe('Framework Agnostic Testing', () => {\n    it('should work with any testing framework', () => {\n      // This test demonstrates that the patterns work with any framework\n      // The actual framework is injected via createTestHelper(vi.fn)\n      expect(testHelper.mockSyntropyLog).toBeDefined();\n      expect(testHelper.mockSyntropyLog.logger).toBeDefined();\n      expect(testHelper.mockSyntropyLog.logger.transports).toHaveLength(1);\n    });\n\n    it('should provide spy functions for assertions', () => {\n      const logger = testHelper.mockSyntropyLog.logger;\n      \n      logger.info('Test message');\n      \n      // The spy functions work like native framework spies\n      expect(logger.info).toHaveBeenCalledWith('Test message');\n      expect(logger.info).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('Declarative Patterns', () => {\n    it('should focus on behavior, not implementation', async () => {\n      const user = { id: 789, name: 'Bob', email: 'bob@example.com' };\n      \n      await notificationService.sendWelcomeNotification(user);\n      \n      // Assert the outcome, not the internal implementation\n      const entries = testHelper.mockSyntropyLog.logger.transports[0].getEntries();\n      expect(entries).toContainEqual(\n        expect.objectContaining({\n          level: 'info',\n          message: 'Welcome notification sent',\n          userId: 789,\n          email: 'bob@example.com'\n        })\n      );\n    });\n\n    it('should test business logic, not framework internals', async () => {\n      const user = { id: 999, name: 'Alice', email: 'alice@example.com' };\n      \n      await notificationService.sendPasswordReset(user);\n      \n      // Test that the business logic works correctly\n      const entries = testHelper.mockSyntropyLog.logger.transports[0].getEntries();\n      const resetRequested = entries.find(e => e.message === 'Password reset requested');\n      const resetSent = entries.find(e => e.message === 'Password reset email sent');\n      \n      expect(resetRequested).toBeDefined();\n      expect(resetSent).toBeDefined();\n      expect(resetRequested?.userId).toBe(999);\n      expect(resetSent?.userId).toBe(999);\n    });\n  });\n\n  describe('Combining All Patterns', () => {\n    it('should demonstrate comprehensive testing approach', async () => {\n      const users = [\n        { id: 1, name: 'User1', email: 'user1@example.com' },\n        { id: 2, name: 'User2', email: 'user2@example.com' }\n      ];\n      \n      // Test multiple operations\n      await Promise.all([\n        notificationService.sendWelcomeNotification(users[0]),\n        notificationService.sendPasswordReset(users[1])\n      ]);\n      \n      const entries = testHelper.mockSyntropyLog.logger.transports[0].getEntries();\n      \n      // Verify all expected log entries\n      expect(entries).toHaveLength(4);\n      expect(entries).toContainEqual(\n        expect.objectContaining({\n          message: 'Sending welcome notification',\n          userId: 1\n        })\n      );\n      expect(entries).toContainEqual(\n        expect.objectContaining({\n          message: 'Password reset requested',\n          userId: 2\n        })\n      );\n    });\n  });\n\n  describe('Framework Boilerplate Testing', () => {\n    it('should test initialization function', async () => {\n      const result = await initializeSyntropyLog();\n      expect(result).toBeDefined();\n      expect(result.getLogger).toBeDefined();\n    });\n\n    it('should test shutdown function', async () => {\n      const result = await shutdownSyntropyLog();\n      expect(result).toEqual({ success: true });\n    });\n  });\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"test-coverage",children:"Test Coverage"}),"\n",(0,r.jsxs)(n.p,{children:["This example achieves ",(0,r.jsx)(n.strong,{children:"100% test coverage"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Tests:       10 passed, 10 total\nSnapshots:   0 total\nTime:        2.1s\nRan all test suites.\n\n----------|---------|----------|---------|---------|-------------------\nFile      | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s \n----------|---------|----------|---------|---------|-------------------\nAll files |     100 |      100 |     100 |     100 |                   \n----------|---------|----------|---------|---------|-------------------\n"})}),"\n",(0,r.jsx)(n.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,r.jsx)(n.h3,{id:"1-transports-are-spies",children:(0,r.jsx)(n.strong,{children:"1. Transports are Spies"})}),"\n",(0,r.jsx)(n.p,{children:"Transports capture log entries in memory for testing, just like spies capture function calls."}),"\n",(0,r.jsx)(n.h3,{id:"2-framework-agnostic-testing",children:(0,r.jsx)(n.strong,{children:"2. Framework Agnostic Testing"})}),"\n",(0,r.jsx)(n.p,{children:"All testing patterns work with any framework through spy function injection."}),"\n",(0,r.jsx)(n.h3,{id:"3-declarative-patterns",children:(0,r.jsx)(n.strong,{children:"3. Declarative Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"Tests focus on behavior and outcomes, not implementation details."}),"\n",(0,r.jsx)(n.h3,{id:"4-comprehensive-coverage",children:(0,r.jsx)(n.strong,{children:"4. Comprehensive Coverage"})}),"\n",(0,r.jsx)(n.p,{children:"Test both business logic and framework boilerplate functions."}),"\n",(0,r.jsx)(n.h3,{id:"5-zero-external-dependencies",children:(0,r.jsx)(n.strong,{children:"5. Zero External Dependencies"})}),"\n",(0,r.jsx)(n.p,{children:"No external services needed - everything runs in memory."}),"\n",(0,r.jsx)(n.h3,{id:"6-silent-observer-philosophy",children:(0,r.jsx)(n.strong,{children:"6. Silent Observer Philosophy"})}),"\n",(0,r.jsx)(n.p,{children:"Framework errors are reported but never interrupt the application flow."}),"\n",(0,r.jsx)(n.h2,{id:"related-examples",children:"Related Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./testing-patterns-vitest",children:"Example 28: Vitest Testing"})})," - Basic testing patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./testing-patterns-jest",children:"Example 29: Jest Testing"})})," - Jest-specific patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./testing-redis-context",children:"Example 30: Redis Context"})})," - Redis testing patterns"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"./testing-serializers",children:"Example 31: Serializers Testing"})})," - Serializer testing patterns"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Run the example"}),": ",(0,r.jsx)(n.code,{children:"cd 32-testing-transports-concepts && npm test"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Explore the code"}),": Review the notification service and tests"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Apply to your project"}),": Use these patterns in your own transport testing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Extend the patterns"}),": Add more complex notification scenarios"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Combine patterns"}),": Use all testing concepts together in your projects"]}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);